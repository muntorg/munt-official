// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from libunity.djinni

#import "DBAddressRecord.h"
#import "DBBlockInfoRecord.h"
#import "DBLegacyWalletResult.h"
#import "DBMnemonicRecord.h"
#import "DBMonitorRecord.h"
#import "DBMutationRecord.h"
#import "DBPaymentResultStatus.h"
#import "DBQrCodeRecord.h"
#import "DBTransactionRecord.h"
#import "DBUriRecipient.h"
#import "DBUriRecord.h"
#import "DBWalletLockStatus.h"
#import <Foundation/Foundation.h>
@protocol DBILibraryListener;
@protocol DBMonitorListener;

/** Interface constants */
extern int32_t const DBILibraryControllerVersion;

/**
 * The library controller is used to Init/Terminate the library, and other similar tasks.
 * It is also home to various generic utility functions that don't (yet) have a place in more specific controllers
 * Specific functionality should go in specific controllers; account related functionality -> accounts_controller, network related functionality -> network_controller and so on
 */
@interface DBILibraryController : NSObject

/** Get the build information (ie. commit id and status) */
+ (nonnull NSString *)BuildInfo;

/**
 * Start the library
 * extraArgs - any additional commandline arguments as could normally be passed to the daemon binary
 * NB!!! This call blocks until the library is terminated, it is the callers responsibility to place it inside a thread or similar.
 * If you are in an environment where this is not possible (node.js for example use InitUnityLibThreaded instead which places it in a thread on your behalf)
 */
+ (int32_t)InitUnityLib:(nonnull NSString *)dataDir
       staticFilterPath:(nonnull NSString *)staticFilterPath
     staticFilterOffset:(int64_t)staticFilterOffset
     staticFilterLength:(int64_t)staticFilterLength
                testnet:(BOOL)testnet
                spvMode:(BOOL)spvMode
          signalHandler:(nullable id<DBILibraryListener>)signalHandler
              extraArgs:(nonnull NSString *)extraArgs;

/** Threaded implementation of InitUnityLib */
+ (void)InitUnityLibThreaded:(nonnull NSString *)dataDir
            staticFilterPath:(nonnull NSString *)staticFilterPath
          staticFilterOffset:(int64_t)staticFilterOffset
          staticFilterLength:(int64_t)staticFilterLength
                     testnet:(BOOL)testnet
                     spvMode:(BOOL)spvMode
               signalHandler:(nullable id<DBILibraryListener>)signalHandler
                   extraArgs:(nonnull NSString *)extraArgs;

/** Create the wallet - this should only be called after receiving a `notifyInit...` signal from InitUnityLib */
+ (BOOL)InitWalletFromRecoveryPhrase:(nonnull NSString *)phrase
                            password:(nonnull NSString *)password;

/** Continue creating wallet that was previously erased using EraseWalletSeedsAndAccounts */
+ (BOOL)ContinueWalletFromRecoveryPhrase:(nonnull NSString *)phrase
                                password:(nonnull NSString *)password;

/** Create the wallet - this should only be called after receiving a `notifyInit...` signal from InitUnityLib */
+ (BOOL)InitWalletLinkedFromURI:(nonnull NSString *)linkedUri
                       password:(nonnull NSString *)password;

/** Continue creating wallet that was previously erased using EraseWalletSeedsAndAccounts */
+ (BOOL)ContinueWalletLinkedFromURI:(nonnull NSString *)linkedUri
                           password:(nonnull NSString *)password;

/** Create the wallet - this should only be called after receiving a `notifyInit...` signal from InitUnityLib */
+ (BOOL)InitWalletFromAndroidLegacyProtoWallet:(nonnull NSString *)walletFile
                                   oldPassword:(nonnull NSString *)oldPassword
                                   newPassword:(nonnull NSString *)newPassword;

/** Check if a file is a valid legacy proto wallet */
+ (DBLegacyWalletResult)isValidAndroidLegacyProtoWallet:(nonnull NSString *)walletFile
                                            oldPassword:(nonnull NSString *)oldPassword;

/** Check link URI for validity */
+ (BOOL)IsValidLinkURI:(nonnull NSString *)phrase;

/** Replace the existing wallet accounts with a new one from a linked URI - only after first emptying the wallet. */
+ (BOOL)ReplaceWalletLinkedFromURI:(nonnull NSString *)linkedUri
                          password:(nonnull NSString *)password;

/**
 * Erase the seeds and accounts of a wallet leaving an empty wallet (with things like the address book intact)
 * After calling this it will be necessary to create a new linked account or recovery phrase account again.
 * NB! This will empty a wallet regardless of whether it has funds in it or not and makes no provisions to check for this - it is the callers responsibility to ensure that erasing the wallet is safe to do in this regard.
 */
+ (BOOL)EraseWalletSeedsAndAccounts;

/**
 * Check recovery phrase for (syntactic) validity
 * Considered valid if the contained mnemonic is valid and the birth-number is either absent or passes Base-10 checksum
 */
+ (BOOL)IsValidRecoveryPhrase:(nonnull NSString *)phrase;

/** Generate a new recovery mnemonic */
+ (nonnull DBMnemonicRecord *)GenerateRecoveryMnemonic;

+ (nonnull NSString *)GenerateGenesisKeys;

/** Compute recovery phrase with birth number */
+ (nonnull DBMnemonicRecord *)ComposeRecoveryPhrase:(nonnull NSString *)mnemonic
                                          birthTime:(int64_t)birthTime;

/** Stop the library */
+ (void)TerminateUnityLib;

/** Generate a QR code for a string, QR code will be as close to widthHint as possible when applying simple scaling. */
+ (nonnull DBQrCodeRecord *)QRImageFromString:(nonnull NSString *)qrString
                                    widthHint:(int32_t)widthHint;

/** Get a receive address for the active account */
+ (nonnull NSString *)GetReceiveAddress;

/** Get the recovery phrase for the wallet */
+ (nonnull DBMnemonicRecord *)GetRecoveryPhrase;

/** Check if the wallet is using a mnemonic seed ie. recovery phrase (else it is a linked wallet) */
+ (BOOL)IsMnemonicWallet;

/** Check if the phrase mnemonic is a correct one for the wallet (phrase can be with or without birth time) */
+ (BOOL)IsMnemonicCorrect:(nonnull NSString *)phrase;

/**
 * Get the 'dictionary' of valid words that a recovery phrase can be composed of
 * NB! Not all combinations of these words are valid
 * Do not use this to generate/compose your own phrases - always use 'GenerateRecoveryMnemonic' for this
 * This function should only be used for input validation/auto-completion
 */
+ (nonnull NSArray<NSString *> *)GetMnemonicDictionary;

/** Unlock wallet; wallet will automatically relock after "timeoutInSeconds" */
+ (BOOL)UnlockWallet:(nonnull NSString *)password
    timeoutInSeconds:(int64_t)timeoutInSeconds;

/** Forcefully lock wallet again */
+ (BOOL)LockWallet;

+ (nonnull DBWalletLockStatus *)GetWalletLockStatus;

/** Change the wallet password */
+ (BOOL)ChangePassword:(nonnull NSString *)oldPassword
           newPassword:(nonnull NSString *)newPassword;

/** Rescan blockchain for wallet transactions */
+ (void)DoRescan;

/** Check if text/address is something we are capable of sending money too */
+ (nonnull DBUriRecipient *)IsValidRecipient:(nonnull DBUriRecord *)request;

/** Check if text/address is a native (to our blockchain) address */
+ (BOOL)IsValidNativeAddress:(nonnull NSString *)address;

/** Check if text/address is a valid bitcoin address */
+ (BOOL)IsValidBitcoinAddress:(nonnull NSString *)address;

/** Compute the fee required to send amount to given recipient */
+ (int64_t)feeForRecipient:(nonnull DBUriRecipient *)request;

/** Attempt to pay a recipient, will throw on failure with description */
+ (DBPaymentResultStatus)performPaymentToRecipient:(nonnull DBUriRecipient *)request
                                      substractFee:(BOOL)substractFee;

/**
 * Get the wallet transaction for the hash
 * Will throw if not found
 */
+ (nonnull DBTransactionRecord *)getTransaction:(nonnull NSString *)txHash;

/** resubmit a transaction to the network, returns the raw hex of the transaction as a string or empty on fail */
+ (nonnull NSString *)resendTransaction:(nonnull NSString *)txHash;

/** Get list of all address book entries */
+ (nonnull NSArray<DBAddressRecord *> *)getAddressBookRecords;

/** Add a record to the address book */
+ (void)addAddressBookRecord:(nonnull DBAddressRecord *)address;

/** Delete a record from the address book */
+ (void)deleteAddressBookRecord:(nonnull DBAddressRecord *)address;

/** Interim persist and prune of state. Use at key moments like app backgrounding. */
+ (void)PersistAndPruneForSPV;

/**
 * Reset progress notification. In cases where there has been no progress for a long time, but the process
 * is still running the progress can be reset and will represent work to be done from this reset onwards.
 * For example when the process is in the background on iOS for a long long time (but has not been terminated
 * by the OS) this might make more sense then to continue the progress from where it was a day or more ago.
 */
+ (void)ResetUnifiedProgress;

/** Get info of last blocks (at most 32) in SPV chain */
+ (nonnull NSArray<DBBlockInfoRecord *> *)getLastSPVBlockInfos;

+ (float)getUnifiedProgress;

+ (nonnull DBMonitorRecord *)getMonitoringStats;

+ (void)RegisterMonitorListener:(nullable id<DBMonitorListener>)listener;

+ (void)UnregisterMonitorListener:(nullable id<DBMonitorListener>)listener;

+ (nonnull NSDictionary<NSString *, NSString *> *)getClientInfo;

/**
 * Get list of wallet mutations
 *NB! This is SPV specific, non SPV wallets should use account specific getMutationHistory on an accounts controller instead
 */
+ (nonnull NSArray<DBMutationRecord *> *)getMutationHistory;

/**
 * Get list of all transactions wallet has been involved in
 *NB! This is SPV specific, non SPV wallets should use account specific getTransactionHistory on an accounts controller instead
 */
+ (nonnull NSArray<DBTransactionRecord *> *)getTransactionHistory;

/**
 * Check if the wallet has any transactions that are still pending confirmation, to be used to determine if e.g. it is safe to perform a link or whether we should wait.
 *NB! This is SPV specific, non SPV wallets should use HaveUnconfirmedFunds on wallet controller instead
 */
+ (BOOL)HaveUnconfirmedFunds;

/**
 * Check current wallet balance (including unconfirmed funds)
 *NB! This is SPV specific, non SPV wallets should use GetBalance on wallet controller instead
 */
+ (int64_t)GetBalance;

@end
