// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from libunity.djinni

#ifndef DJINNI_GENERATED_NJSIWALLETLISTENER_HPP
#define DJINNI_GENERATED_NJSIWALLETLISTENER_HPP


#include "balance_record.hpp"
#include "input_record.hpp"
#include "mutation_record.hpp"
#include "output_record.hpp"
#include "transaction_record.hpp"

#include <napi.h>
#include <uv.h>
#include <i_wallet_listener.hpp>

using namespace std;

class NJSIWalletListener: public Napi::ObjectWrap<NJSIWalletListener> {
public:

    static Napi::FunctionReference constructor;
    static Napi::Object Init(Napi::Env env, Napi::Object exports);
    NJSIWalletListener(const Napi::CallbackInfo& info) : Napi::ObjectWrap<NJSIWalletListener>(info){};

    void notifyBalanceChange(const BalanceRecord & new_balance);

    /**
     * Notification of new mutations.
     * If self_committed it is due to a call to performPaymentToRecipient, else it is because of a transaction
     * reached us in another way. In general this will be because we received funds from someone, hower there are
     * also cases where funds is send from our wallet while !self_committed (for example by a linked desktop wallet
     * or another wallet instance using the same keys as ours).
     *
     * Note that no notifyNewMutation events will fire until after 'notifySyncDone'
     * Therefore it is necessary to first fetch the full mutation history before starting to listen for this event.
     */
    void notifyNewMutation(const MutationRecord & mutation, bool self_committed);

    /**
     * Notification that an existing transaction/mutation  has updated
     *
     * Note that no notifyUpdatedTransaction events will fire until after 'notifySyncDone'
     * Therefore it is necessary to first fetch the full mutation history before starting to listen for this event.
     */
    void notifyUpdatedTransaction(const TransactionRecord & transaction);

private:
    void notifyBalanceChange(const Napi::CallbackInfo& info);
    void notifyBalanceChange_aimpl__(const BalanceRecord & new_balance);

    /**
     * Notification of new mutations.
     * If self_committed it is due to a call to performPaymentToRecipient, else it is because of a transaction
     * reached us in another way. In general this will be because we received funds from someone, hower there are
     * also cases where funds is send from our wallet while !self_committed (for example by a linked desktop wallet
     * or another wallet instance using the same keys as ours).
     *
     * Note that no notifyNewMutation events will fire until after 'notifySyncDone'
     * Therefore it is necessary to first fetch the full mutation history before starting to listen for this event.
     */
    void notifyNewMutation(const Napi::CallbackInfo& info);
    void notifyNewMutation_aimpl__(const MutationRecord & mutation, bool self_committed);

    /**
     * Notification that an existing transaction/mutation  has updated
     *
     * Note that no notifyUpdatedTransaction events will fire until after 'notifySyncDone'
     * Therefore it is necessary to first fetch the full mutation history before starting to listen for this event.
     */
    void notifyUpdatedTransaction(const Napi::CallbackInfo& info);
    void notifyUpdatedTransaction_aimpl__(const TransactionRecord & transaction);

};
#endif //DJINNI_GENERATED_NJSIWALLETLISTENER_HPP
